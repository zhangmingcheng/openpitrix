// Copyright 2018 The OpenPitrix Authors. All rights reserved.
// Use of this source code is governed by a Apache license
// that can be found in the LICENSE file.

// Auto generated by 'go run gen_helper.go', DO NOT EDIT.

package labelutil

import (
	"context"

	"openpitrix.io/openpitrix/pkg/constants"
	"openpitrix.io/openpitrix/pkg/db"
	"openpitrix.io/openpitrix/pkg/gerr"
	"openpitrix.io/openpitrix/pkg/models"
	"openpitrix.io/openpitrix/pkg/pi"
)

func SyncRepoLabels(ctx context.Context, repoId, labelStr string) error {
	labelQuery, err := Parse(labelStr)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorParameterParseFailed, "label")
	}
	var labels []*models.RepoLabel
	_, err = pi.Global().DB(ctx).
		Select(models.RepoLabelColumns...).
		From(constants.TableRepoLabel).
		Where(db.Eq(constants.ColumnRepoId, repoId)).
		OrderDir(constants.ColumnCreateTime, true).
		Load(&labels)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorDescribeResourcesFailed)
	}
	i := 0
	// update exists label
	// insert new label
	// delete outmoded label
	insert := pi.Global().DB(ctx).InsertInto(constants.TableRepoLabel)
	for _, q := range labelQuery {
		if len(labels) >= i+1 {
			label := labels[i]
			if label.LabelKey != q.K || label.LabelValue != q.V {
				_, err = pi.Global().DB(ctx).
					Update(constants.TableRepoLabel).
					Set(constants.ColumnLabelKey, q.K).
					Set(constants.ColumnLabelValue, q.V).
					Where(db.Eq(constants.ColumnRepoLabelId, label.RepoLabelId)).
					Exec()
				if err != nil {
					return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
				}
			}
		} else {
			repoLabel := models.NewRepoLabel(repoId, q.K, q.V)
			insert = insert.Record(repoLabel)
		}
		i++
	}
	if len(insert.Value) > 0 {
		_, err = insert.Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	if len(labels) >= i+1 {
		var deleteLabelIds []string
		labels = labels[i:]
		for _, label := range labels {
			deleteLabelIds = append(deleteLabelIds, label.RepoLabelId)
		}
		_, err := pi.Global().DB(ctx).
			DeleteFrom(constants.TableRepoLabel).
			Where(db.Eq(constants.ColumnRepoLabelId, deleteLabelIds)).
			Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	return err
}

func SyncRepoSelectors(ctx context.Context, repoId, selectorStr string) error {
	selectorQuery, err := Parse(selectorStr)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorParameterParseFailed, "selector")
	}
	var selectors []*models.RepoSelector
	_, err = pi.Global().DB(ctx).
		Select(models.RepoSelectorColumns...).
		From(constants.TableRepoSelector).
		Where(db.Eq(constants.ColumnRepoId, repoId)).
		OrderDir(constants.ColumnCreateTime, true).
		Load(&selectors)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorDescribeResourcesFailed)
	}
	i := 0
	// update exists selector
	// insert new selector
	// delete outmoded selector
	insert := pi.Global().DB(ctx).InsertInto(constants.TableRepoSelector)
	for _, q := range selectorQuery {
		if len(selectors) >= i+1 {
			selector := selectors[i]
			if selector.SelectorKey != q.K || selector.SelectorValue != q.V {
				_, err = pi.Global().DB(ctx).
					Update(constants.TableRepoSelector).
					Set(constants.ColumnSelectorKey, q.K).
					Set(constants.ColumnSelectorValue, q.V).
					Where(db.Eq(constants.ColumnRepoSelectorId, selector.RepoSelectorId)).
					Exec()
				if err != nil {
					return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
				}
			}
		} else {
			repoSelector := models.NewRepoSelector(repoId, q.K, q.V)
			insert = insert.Record(repoSelector)
		}
		i++
	}
	if len(insert.Value) > 0 {
		_, err = insert.Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	if len(selectors) >= i+1 {
		var deleteSelectorIds []string
		selectors = selectors[i:]
		for _, selector := range selectors {
			deleteSelectorIds = append(deleteSelectorIds, selector.RepoSelectorId)
		}
		_, err := pi.Global().DB(ctx).
			DeleteFrom(constants.TableRepoSelector).
			Where(db.Eq(constants.ColumnRepoSelectorId, deleteSelectorIds)).
			Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	return err
}
